/* ----------------------------------------------------------------------- */
/* Template source file generated by piklab */
#include <pic16f631.h>
// TODO GIANT RESTRUCTURING: 16f630 -> 16f631 (IR needs no change, just generalisation)

/* ----------------------------------------------------------------------- */
/* Configuration bits: adapt to your setup and needs */
typedef unsigned int word;
word __at 0x2007 CONFIG = _INTRC_OSC_NOCLKOUT & _WDT_OFF & _PWRTE_OFF & _MCLRE_OFF & _CP_OFF & _CPD_OFF & _BOR_ON & _IESO_OFF & _FCMEN_OFF;

/* ----------------------------------------------------------------------- */
/* Functions */
#include "functions.h"
int placeholder;

/* ----------------------------------------------------------------------- */
/* Interrupt */
static void IR(void) __interrupt 0
{
  int address = 0;
  short int command = 0;
  int i;
  // IR handling function
  if (!RA3) // Check whether RA3 is LOW
  {
    if(lead_time_check())
    {
      for(i = 0; i < 16; i++)
      {
	address << 1;
	address + bit_check();
      }
      for(i = 0; i < 16; i++)
      {
	command << 1;
	command + bit_check();
      }
    }
    /* TODO:
     * -Lead in check -> IN PROGRESS
     * -Logical bit checks (0 and 1) -> PLACEHOLDER
     * -Storing bits into variables (address and command) (bitshifts) -> DONE
     * -Address -> either classic (8-bit normal and inverse) or extended (16-bit long address) -> 16-bits probably
     * -Comparing bitwise command to inverse-command -> NOTHING YET
     * -OPTIONAL: handling of repeat signal -> NOTHING YET
     * Note to self: learn pic timer! -> IN PROGRESS
     */
  }
  RAIF = 0; // Reset interrupt bit
}

void main() {
  unsigned int curr_scart = 0; // Active scart port [0-7]
  OPTION_REG = 0b01001111; // PORTA pull ups are enabled, setting up TMR0
  // (|-> div by 1, set prescaler to WDT, rising edge, internal clock (intrinsic div by 4!))
  PORTC = 0xFE; // PORTC is going to be HIGH when set to OUTPUT, except PORTC0, which is LOW
  // TODO Save last scart position to flash, so that it can be loaded on next bootup... but with 100 000 write cycles... is it justified?
  PORTA = 0x03; // First 2 PORTA init. to HIGH
  TRISC = 0x00; // Setting PORTC to output
  TRISA = 0xFC; // 2 PORTA pins to OUTPUT, rest stays on INPUT
  // Setting up for interrupt handling
  INTCON = 0; // All interrupt bits to 0 (INTerrupt CONtroll)
  IOCA = 0; // Init IOCA register
  GIE = 1; // Global Interrupt Enable
  RAIE = 1; // PORTA(RA) Interrupt Enable - to enable interrupt on port change
  IOCA3 = 1; // Interrupt occurs only when there's change on RA3
  // main loop
  while(1)
  {
    if(RA4 == 1 && RA5 == 0) // If A4 is HIGH and A5 is LOW, then move active scart input to the previous one (move backwards)
    {
      switch_backwards(&curr_scart);
      RAIE = 0; // Disable interrupt for the duration of the delay (invokes bug in asm code otherwise)
      delay_ms(200); // Wait ~0.5s before next check
      RAIE = 1;
    }
    if(RA5 == 1 && RA4 == 0) // If A5 is HIGH and A4 is LOW, then move active scart input to the next one (move forward)
    {
      switch_forward(&curr_scart);
      RAIE = 0; // Disable interrupt for the duration of the delay (invokes bug in asm code otherwise)
      delay_ms(200); // Wait ~0.5s before next check
      RAIE = 1;
    }
    // TODO Maybe implement switching through selecting first the number then switching to it... from anywhere
    // TODO IR transmition decoding - Implement it in interrupt
  }
}

